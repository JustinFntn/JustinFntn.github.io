{"config":{"indexing":"full","lang":["fr"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python pour les d\u00e9butants Bienvenue! Vous \u00eates compl\u00e8tement novice en programmation? Heureusement, n'importe quel programmeur peut apprendre \u00e0 programmer en Python. Il est facile \u00e0 utiliser et \u00e0 apprendre pour les d\u00e9butants, alors lancez-vous ! def exemple(): print(\"Bonjour, le monde!\") Pourquoi Python? Python est un langage de programmation populaire. Il est utilis\u00e9 pour de nombreux types de projets, tels que: D\u00e9veloppement Web Analyse de donn\u00e9es Intelligence artificielle Automatisation Et bien plus encore!","title":"Accueil"},{"location":"#python-pour-les-debutants","text":"Bienvenue! Vous \u00eates compl\u00e8tement novice en programmation? Heureusement, n'importe quel programmeur peut apprendre \u00e0 programmer en Python. Il est facile \u00e0 utiliser et \u00e0 apprendre pour les d\u00e9butants, alors lancez-vous ! def exemple(): print(\"Bonjour, le monde!\")","title":"Python pour les d\u00e9butants"},{"location":"#pourquoi-python","text":"Python est un langage de programmation populaire. Il est utilis\u00e9 pour de nombreux types de projets, tels que: D\u00e9veloppement Web Analyse de donn\u00e9es Intelligence artificielle Automatisation Et bien plus encore!","title":"Pourquoi Python?"},{"location":"conventions/","text":"Documentation Python Cette page r\u00e9pertorie toutes les conventions que nous appliquerons aux d\u00e9veloppements impliquant du Python, elles permettront d'uniformiser notre code afin de faciliter la reprise, la maintenance et la compr\u00e9hension par nos successeurs. La documentation qualit\u00e9 s'appuiera sur la PEP 8 afin de la rendre la plus g\u00e9n\u00e9rique et \u00e9volutive possible.Tout en ajoutant et en modifiant certains \u00e9l\u00e9ments. ( PEP 8 ) La PEP 8 Introduction La PEP 8 est un document \u00e9crit par les cr\u00e9ateurs de Python, il contient les conventions de codage Python les plus r\u00e9pendues de nos jours, elle est r\u00e9guli\u00e8rement mise \u00e0 jour et disponible pour tous. Il en existe \u00e9galement une d\u00e9clinaison pour la langage C, mais nous ne la d\u00e9taillerons pas ici. L'objectif principal des normes est de rendre le code plus lisible et plus simple \u00e0 reprendre, on n'a pas forc\u00e9ment envie de reprendre 3000 lignes empact\u00e9es sans instructions, pas vrai ? ;) Voici donc quelques cr\u00e9dos qui pourront vous guider dans votre reflexion : PEP 20 Application Le plus important lors de l'\u00e9criture d'un code est l'assiduit\u00e9, et encore plus lors de l'\u00e9criture d'une fonction ou d'un petit bout de code, c'est \u00e0 ce moment qu'il faudra la rendre la plus g\u00e9n\u00e9rique possible pour qu'elle soit potentiellement r\u00e9utilisable dans des projets futurs ou m\u00eame dans le m\u00eame projet, c'est toujours plaisant de pouvoir r\u00e9utiliser quelque chose qui marche bien sans avoir \u00e0 tout r\u00e9\u00e9crire ! Cependant dans certains cas ces recommendations ne sont pas forc\u00e9ment \u00e0 appliquer surtout si le projet ne s'y pr\u00eate pas, ou bien dans le cas de l'utilisation d'un framework particulier qui n\u00e9cessiterait une syntaxe particuli\u00e8re (exemple: d\u00e9corateurs des routes Flask) Quelques exemples de cas o\u00f9 l'application des principes pourrait \u00eatre \u00e0 \u00e9viter: Suivre le guide rendrait le code moins lisible Le code autours suit une autre convention La version de Python utilis\u00e9e dans le reste du code n'est pas compatible avec la nouvelle syntaxe Structuration du code Indentation L'indentation des lignes se fait \u00e0 l'aide des espaces, 1 indentation = 4 espaces Si vous utilisez VSCode pour travailler, vous pouvez d\u00e9finir ce param\u00e8tre dans la barre d'outils tout en bas : Spaces > Change tab display size > 4. Les fonctions Lors de l'\u00e9criture d'une fonction ou d'un appel fonction, les arguments peuvent prendre \u00e9norm\u00e9ment de place sur la ligne, nous verrons plus tard la limite \u00e0 respecter, en attendant, lorsque l'appel ou la liste d'arguments est trop longue, les arguments doivent \u00eatre plac\u00e9s \u00e0 la ligne: # On peut aligner les arguments sur la paranth\u00e8se d'ouverture def nom_de_fonction_long(param_1, param_2, param_3, param_4): print(param_1) resultat = nom_de_fonction_long(param_1, param_2, param_3, param_4) # Ou alors # On placera les arguments en dessous avec une indentation suppl\u00e9mentaire par rapport au code de la fonction # Afin de diff\u00e9rencier les arguments du code def nom_de_fonction_long( param_1, param_2, param_3, param_4): print(param_1) resultat = nom_de_fonction_long( param_1, param_2, param_3, param_4) # Ou: resultat = nom_de_fonction_long( param_1, param_2, param_3, param_4 ) Les conditions Lors de la constitution d'une condition, il se peut qu'il y ait plusieurs \"and\" ou \"or\", cela peut rendre la ligne particuli\u00e8rement longue, ainsi nous ferons le d\u00e9coupage de la mani\u00e8re suivante: # Chaque 'and' ou 'or' sera sur une nouvelle ligne 4 espaces plus loin que la parenth\u00e8se d'ouverture, soit 1 indentation. if (condition1 and condition2 and condition3 or condition4): return Les listes et dictionnaires Afin de conserver une forme qui reste lisible lors de la d\u00e9finition d'une liste ou d'un dictionnaire, s'il s'agit d'un objet \u00e0 plusieurs dimensions, on gardera toujours une forme coh\u00e9rente avec la forme r\u00e9elle qu'aura l'objet. # Dans le cas d'une liste \u00e0 1 dimension: ma_liste = [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ] # 2 dimensions: ma_liste = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10] ] # 3 dimensions: ma_liste = [ [ [1, 2, 3], [4, 5, 6] ], [ [7, 8, 9], [10, 11, 12] ] ] # Et ainsi de suite.. # Pour les dictionnaires : mon_dico = { '1': 'oui', '2': 'stiti' } Longueur des lignes \u00e0 respecter Quand on lit un code, c'est pas marrant de scroller \u00e0 l'infini \u00e0 l'horizontale ! Pour \u00e9viter \u00e7a, on va limiter la longueur des lignes de code de mani\u00e8re \u00e0 tout garder visible \u00e0 l'\u00e9cran pour un maximum de r\u00e9solutions diff\u00e9rentes, il a donc \u00e9t\u00e9 d\u00e9cid\u00e9 que la longueur parfaite \u00e9tait de 100 caract\u00e8res maximum par ligne de code Pour ce qui est des commentaires ou des docstrings , on se limitera \u00e0 72 caract\u00e8res La seconde raison de cette limite est la possibilit\u00e9 d'avoir plusieurs \u00e9diteurs de code ouverts simultan\u00e9ment sur un m\u00eame \u00e9cran, en les mettant c\u00f4te \u00e0 c\u00f4te, avoir des lignes pas trop longues permet d'avoir une vue d'ensemble de tous les codes que nous souhaitons voir, ainsi pour les review ou m\u00eame pour coder sur diff\u00e9rentes composantes en m\u00eame temps, il est plus simple de se restreindre. Pour \u00e9viter de d\u00e9passer cette limite, on peut faire comme vu pr\u00e9c\u00e9demment, lorsqu'on est dans une parenth\u00e8se on peut passer \u00e0 la ligne. En revanche dans le cas d'un \"with\" avec plusieurs ouvertures, ou d'un \"assert\", l'utilisation du \\ peut \u00eatre utile. Voici un exemple d'utilisation: # Chaque 'and' ou 'or' sera sur une nouvelle ligne 4 espaces plus loin que la parenth\u00e8se d'ouverture, soit 1 indentation. with open('/chemin/vers/un/fichier') as fichier_1, \\\\ open('/chemin/vers/un/fichier', 'w') as fichier_2: fichier_2.write(fichier_1.read()) Les op\u00e9rateurs Vous avez beaucoup de calculs \u00e0 faire ? Vous n'allez tout de m\u00eame pas tout mettre sur la m\u00eame ligne apr\u00e8s tout ce qu'on vient de dire ? ;) Pour chaque bloc d'op\u00e9ration, nous s\u00e9parerons en faisant un saut \u00e0 la ligne et en mettant l'op\u00e9rateur en d\u00e9but de ligne comme ceci: # L'op\u00e9rateur sera align\u00e9 avec la parenth\u00e8se d'ouverture revenu = (salaire - budget_codage + prime_de_votre_gentil_chef * 1.1) #Pour le plaisir Les sauts de lignes C'est bien connu, un gros bloc, \u00e7a donne pas envie de lire. On va donc espacer notre code en sautant des lignes aux bons endroits et sans en abuser pour ne pas retirer la coh\u00e9rence du code. # 1. Un saut de ligne entre les fonctions def func_1(): return def func_2(): return # 2. Deux sauts de ligne entre les m\u00e9thodes de classe et les fonctions def methode(self): return def fonction(): return # 3. Un saut de ligne entre un code et une condition variable = 1 test = 2 if variable == 1: return # 4. Dans les fonctions, 1 saut de ligne entre chaque bloc logique def fonction(): variable = 1 autre_variable = 1 with open('test') as test: print(test) return Les imports Les imports devront toujours se situer au d\u00e9but du code apr\u00e8s le header de documentation , jamais plus loin. Il faudra les d\u00e9coupler sur plusieurs lignes s'ils ne sont pas li\u00e9s entre eux. Ils devront \u00eatre import\u00e9s dans l'ordre suivant: Librairies standard Python Librairies tierces Modules internes au code # Correct: import os import sys # Dans le cas d'imports venant d'un m\u00eame package, il est recommand\u00e9 de les mettre sur la m\u00eame ligne: from subprocess import Popen, PIPE # Les imports absolus sont recommand\u00e9s quand la structure du projet est complexe from . import voisin from .voisin import fonction La documentation du module Au d\u00e9but d'un module, avant tout code, il faut bien \u00e9crire la documentation afin de savoir tout de suite quelle est son utilit\u00e9 ou encore \u00e0 qui se r\u00e9ferrer s'il y a un probl\u00e8me ou des questions. Cette documentation fait partie du \"docstring\" qui est un peu la \"carte d'identit\u00e9\" du projet, on va documenter chaque module et chaque fonction. Tout d'abord pour les modules, la documentation se pr\u00e9sentera comme ceci: \"\"\"Module d exemple Description de la fonction principale du module, ex: Permet d exporter des donn\u00e9es au format CSV \"\"\" from __future__ import annotations __all__ = [\"variable1\", \"variable2\", \"variable3\"] __version__ = \"1.0\" __author__ = \"Alex Lovergne\" import os import sys def fonction_exemple(arg1: String, arg2: String) -> String: \"\"\"Fonction d exemple, d\u00e9finition de son utilit\u00e9 args: - arg1 : String -> Premi\u00e8re chaine de caract\u00e8re - arg2 : String -> Deuxi\u00e8me chaine de caract\u00e8re \u00e0 concat\u00e9ner returns: String -> Concatenation des deux chaines \"\"\" return arg1 + arg2 La variable __all__ permet de d\u00e9finir le nom des variables qui seront export\u00e9es du module, par exemple si on a une variable a = 0 d\u00e9finie dans le module et que l'on importe le module ailleurs, seule la variable a sera import\u00e9e. Les espaces Les espacements dans le code sont tr\u00e8s utiles pour am\u00e9liorer sa lisibilit\u00e9 et le rendre plus a\u00e9r\u00e9. On aime bien avoir de la place entre son canap\u00e9 et sa t\u00e9l\u00e9vision pour bien voir, dans le code c'est pareil. Il est important toute fois de ne pas mettre des espaces partout, il y a des emplacements bien d\u00e9finis pour faciliter la lecture et la d\u00e9tection rapide de certaines instructions ou syntaxes. # Entre les parenth\u00e8ses et les valeurs, pas d'espaces acheter(viande[1], {oeufs: 2}) exemple = (0,) # 1 espace apr\u00e8s les ':' et les ',' mais pas avant. # Jamais d espaces entre le nom de fonction et ses arguments. Entre une liste et ses crochets if x == 4: print(x, y); x, y = y, x def fonction_exemple(arg1: String, arg2: String) -> String: dct['key'] = lst[index] # Toujours un espace de chaque c\u00f4t\u00e9 du '=', '+', '-', '/', '->' i = i + 1 ajout += 1 x = x*2 - 1 hypot2 = x*x + y*y + y / 2 c = (a+b) * (a-b) Les commentaires Rapide point sur les commentaires, vous devez en avoir marre, les commentaires c'est long et barbant \u00e0 faire mais malheureusement c'est ce qui va aider votre prochain (on est pas \u00e0 l'\u00e9glise rassurez vous). Ainsi \u00e9crire des commentaires pour expliquer les points importants du code sont primordiaux surtout s'il s'agit d'un traitement m\u00e9tier qu'un autre d\u00e9veloppeur pourrait ne pas ma\u00eetriser. Attention cependant \u00e0 les utiliser avec mod\u00e9ration, Un commentaire \u00e0 chaque ligne, c'est comme de la moquette sur un mur, c'est d\u00e9rangeant Vous pouvez les mettre sur une nouvelle ligne ou bien en fin de ligne \u00e0 2 espaces d'intervalle de la fin de la ligne de code. N'oubliez pas la limite de caract\u00e8res par ligne ! Les conventions Nommage Les variables et fonctions Les variables doivent toujours avoir un nom explicite , il faut \u00e9viter les variables ayant un nom comme \"a\" ou \"b\", mais plut\u00f4t \"liste mots\" ou \"dico_noms\" par exemple. Ensuite, il y a des conventions sur le nommage des variables, en effet on privil\u00e9giera les **variables en lettres minuscules, s'il y a plusieurs mots on les s\u00e9parera avec un \" \", de la forme : liste_mots_a_trier** (c'est un exemple, ne faites pas des noms aussi longs). Pour ce qui est des fonctions, nous partirons sur le m\u00eame principe, il s'agit du snake_case. Les classes et modules Les noms de classes et les modules ont une syntaxe diff\u00e9rente, au lieu d'utiliser des lettres en minuscule et des tirets du bas, on va utiliser le CamelCase . Il s'agit de nommer en collant les mots, \u00e0 chaque nouveau mot on met une majuscule de cette mani\u00e8re: JeSuisUnNomDeVariable (pas aussi long svp). Les constantes Les constantes seront toujours d\u00e9finies au d\u00e9but du script apr\u00e8s la documentation et les imports. Ou alors dans les fichiers de config, ils seront d\u00e9finis en majuscules, les mots seront s\u00e9par\u00e9s par des \"_\" De la mani\u00e8re suivante: JE_SUIS_UNE_CONSTANTE Petit rappel: Une constante est une variable qui sera d\u00e9finie lors de l'\u00e9criture du code et ne sera JAMAIS modifi\u00e9e apr\u00e8s. Configuration d\u00e9port\u00e9e Quand on a de l'argent liquide, on se prom\u00e8ne jamais avec tout sur nous ? Dans le code c'est pareil , on ne veut pas que nos mots de passes soient visibles pour tous les gens qui auraient acc\u00e8s \u00e0 notre repo git. On n'a pas non plus envie d'aller modifier partout si un mot de passe ou une valeur change ? C'est pour \u00e7a qu'on va d\u00e9porter notre configuration, de cette mani\u00e8re on \u00e9vite tous les probl\u00e8mes occasionn\u00e9s par les chaines \u00e9crites en dur dans le code, mais aussi on renforce la s\u00e9curit\u00e9 de notre programme \u00e9tant donn\u00e9 qu'on ne publiera pas le fichier de config rempli mais plut\u00f4t une version d'exemple pour aiguiller une personne qui voudrait reprendre notre code mais qui n'aurait pas les m\u00eames acc\u00e8s que nous. Mais comment on fait ? C'est tr\u00e8s simple, dans le dossier racine de notre projet, on va cr\u00e9er un nouveau dossier settings . Dans ce dossier nous allons cr\u00e9er un fichier config.ini et config_exemple.ini . Dans le fichier config.ini nous allons placer nos variables qui seront accessibles depuis notre code comme ceci : [exemple_1] host=srv-exemple1 database=microcapteurs user=exemple password=exemple [exemple_2] host=srv-exemple2 database=microcapteurs user=exemple2 password=exemple2 Ensuite, dans notre fichier config_exemple.ini nous allons placer exactement les m\u00eames variables mais en renseignant de fausses informations . Comment r\u00e9cup\u00e9rer nos variables de configuration ? C'est tr\u00e8s simple, dans notre programme Python nous allons utiliser le module \"configparser\" , il s'utilise comme ceci: import configparser config = configparser.ConfigParser() # Initialisation du module config.read('./settings/config.ini') # Import de notre configuration print(config['exemple_1']['host']) # On peut r\u00e9cup\u00e9rer notre configuration \u00e0 la mani\u00e8re d'un dictionnaire print(config['exemple_2']['user']) Logging Il est toujours important de garder une trace de l'ex\u00e9cution de notre programme afin de faciliter son debuggage en cas de probl\u00e8me. Pour cela nous n'utiliserons \u00e9videmment pas la fonction print mais bien la librairie logging Cette librairie Python permet de param\u00e9trer une ou plusieurs sorties pour ce qu'on voudrait afficher/stocker. Il est ainsi possible par exemple pour un logging.info() d'enregistrer le r\u00e9sultat dans un fichier .log mais en m\u00eame temps de l'afficher dans la console. Comment l'utiliser ? Commen\u00e7ons tout d'abord par cr\u00e9er un fichier log-config.ini qui sera situ\u00e9 dans un dossier settings \u00e0 la racine du programme. Dans ce fichier nous pla\u00e7erons ce contenu: [loggers] keys=root [handlers] keys=consoleHandler,fileHandler [formatters] keys=default [logger_root] level=NOTSET handlers=consoleHandler,fileHandler [handler_consoleHandler] class=StreamHandler level=NOTSET formatter=default args=(sys.stdout,) [handler_fileHandler] class=handlers.RotatingFileHandler level=NOTSET args=('debug.log',2000,100) formatter=default encoding=utf-8 [formatter_default] format=%(asctime)s %(levelname)s %(message)s datefmt= style=% validate=True class=logging.Formatter Il s'agira de notre configuration standard qui sera utilis\u00e9e pour tous nos projets, elle permet de log dans la console mais aussi dans un fichier debug.log \u00e0 la racine. Le format de sortie sera du type: YY-MM-DD H:M:S,MS INFO message affich\u00e9 Maintenant que notre fichier de config est cr\u00e9\u00e9, nous pouvons l'importer dans notre programme principal, et en suite utiliser la bibioth\u00e8que logging. import logging import logging.config logging.config.fileConfig('settings/log-config.ini') # Chargement de la config -> 1 seule fois dans le main logging.info('information') # Pour afficher une \u00e9tape par exemple logging.warning('attention') # Exemple: condition non respect\u00e9e mais non bloquante logging.error('erreur') # Erreur, fin du programme D\u00e9pendances Qui n'a jamais r\u00eav\u00e9 de tout installer en une seule commande ? C'est bien pour \u00e7a que les requirements existent et sont utilis\u00e9s. Ils vont permettre d'installer toutes les d\u00e9pendances de notre projet avec une unique commande, ce qui permet d'\u00e9viter les oublis, de fixer une version bien d\u00e9finie avec laquelle le programme est compatible mais aussi de gagner du temps et \u00e9viter les potentielles failles de s\u00e9curit\u00e9. Mais comment qu'on fait ? C'est tr\u00e8s simple, il suffit de cr\u00e9er un fichier requirements.txt \u00e0 la racine du projet. Dans ce fichier nous allons lister nos d\u00e9pendances ainsi que les versions de cette mani\u00e8re: numpy==1.24.2 requests==2.28.2 urllib3==1.26.14 # Module == version Ensuite une fois que c'est fait, on a d\u00e9j\u00e0 fini. Pour installer les d\u00e9pendances il faut taper la commande: pip install -r requirements.txt Modularisation On ne veut pas avoir tout notre code dans un seul fichier, c'est moche de scroll \u00e0 l'infini pas vrai ? On va donc chercher \u00e0 d\u00e9coupler un maximum notre code en plusieurs modules, dans l'id\u00e9al 1 module par utilit\u00e9. Exemple: J'ai un fichier main.py avec 6 fonctions, une pour exporter des donn\u00e9es dans une BDD, une autre pour importer les donn\u00e9es d'une source (microcapteur par exemple), et 4 autres pour faire des conversions. Comment organiser mon code ? Une proposition pourrait \u00eatre de l'organiser de la mani\u00e8re suivante: On va s'assurer que chaque module de donn\u00e9es soit g\u00e9n\u00e9rique, pour se faire nous utiliserons des interfaces (Sensor.py) . \u251c\u2500\u2500 main.py \u251c\u2500\u2500 requirements.txt \u251c\u2500\u2500 debug.log \u251c\u2500\u2500 settings/ \u2502 \u251c\u2500\u2500 config.ini \u2502 \u251c\u2500\u2500 config_example.ini \u2502 \u2514\u2500\u2500 log-config.ini \u251c\u2500\u2500 utils/ \u2502 \u2514\u2500\u2500 converters.py \u251c\u2500\u2500 database/ \u2502 \u2514\u2500\u2500 Database.py \u2514\u2500\u2500 sensors/ \u251c\u2500\u2500 Kunak.py \u2514\u2500\u2500 Sensor.py Les interfaces Qu'est-ce qu'une interface ? Une interface est une classe Python qui permet de d\u00e9finir un cadre qui sera appliqu\u00e9 aux classes h\u00e9ritantes. Mais \u00e7a veut dire quoi ? Voici un exemple simple: J'ai une interface Sensor J'ai une classe Kunak La classe Sensor se d\u00e9finit de la mani\u00e8re suivante: class Sensor: def __init__(self, name: str, constructor: str) -> None: self._name = name self._constructor = constructor @property def name(self) -> str: return self._name @name.setter def name(self, new_name: str): self._name = new_name @property def constructor(self) -> str: return self._constructor @constructor.setter def constructor(self, new_constructor: str): self._constructor = new_constructor def __repr__(self) -> str: return \"<sensor %s - constructor:%s>\" % ( self._name, self._constructor) La classe Kunak, quant a elle est d\u00e9finie comme ceci: class Kunak(Sensor): # H\u00e9rite de l'interface Sensor def __init__(self, *args) -> None: super().__init__(*args) # Charge la classe parent Ainsi, si on cr\u00e9\u00e9 un objet de la classe Kunak on aura: kun = Kunak('K100', 'Kunak') print(kun) >>> <sensor K100 - Kunak> La classe de l'objet sera donc 'Kunak', h\u00e9ritant de Sensor. Elle b\u00e9n\u00e9ficie donc de toutes les m\u00e9thodes et attributs d\u00e9finits dans la classe parent. Bo\u00eete \u00e0 outils SQL Alchemy SQL Alchemy est un module Python qui sert \u00e0 int\u00e9ragir avec la base de donn\u00e9es , on appelle \u00e7a un ORM ou Object-Relational Mapping . Il s'agit d'un type de programme informatique qui se place en interface entre un programme applicatif et une base de donn\u00e9es relationnelle pour simuler une base de donn\u00e9es orient\u00e9e objet. ( Voir wikip\u00e9dia ) Pour utiliser SQL Alchemy et le relier \u00e0 notre base de donn\u00e9es, il est n\u00e9cessaire de cr\u00e9er nos mod\u00e8les . Qu'est-ce qu'un mod\u00e8le ? Un mod\u00e8le dans notre cas est une classe Python portant le nom d'une table de notre base de donn\u00e9es, et qui r\u00e9pertorie les colonnes dont on va avoir besoin. Elles doivent exister dans la BDD. Dans le cas o\u00f9 la BDD n'existerait pas encore, les tables seront cr\u00e9\u00e9es en fonction des mod\u00e8les d\u00e9finis dans le code. Voici un exemple de mod\u00e8le: import sqlalchemy as sa from dbModels.Engine import Base class Capteurs(Base): __tablename__ = 'capteurs' id = sa.Column(sa.Integer, nullable=False, primary_key=True) constructeur = sa.Column(sa.VARCHAR) reference_constructeur = sa.Column(sa.VARCHAR) position_actuelle = sa.Column(sa.VARCHAR) modele = sa.Column(sa.VARCHAR) notes = sa.Column(sa.Text) campagne_mesure_actuelle_id = sa.Column(sa.Integer) date_mise_en_service = sa.Column(sa.Date) date_arret = sa.Column(sa.Date) etat = sa.Column(sa.VARCHAR) def __init__(self, id, constructeur, reference_constructeur, position_actuelle, modele, notes, campagne_mesure_actuelle_id, date_mise_en_service, date_arret, etat): self.id = id self.constructeur = constructeur self.reference_constructeur = reference_constructeur self.position_actuelle = position_actuelle self.modele = modele self.notes = notes self.campagne_mesure_actuelle_id = campagne_mesure_actuelle_id self.date_mise_en_service = date_mise_en_service self.date_arret = date_arret self.etat = etat def __repr__(self): return \"<capteur n\u00b0%s - %s - reference -> %s>\" % ( self.id, self.constructeur, self.reference_constructeur) Et l'engine qui repr\u00e9sente la base de notre connexion \u00e0 la BDD est difini de la mani\u00e8re suivante: from sqlalchemy import create_engine from sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import sessionmaker import configparser config = configparser.ConfigParser() config.read(\"./settings/config.ini\") def loadSession(): metadata = Base.metadata Session = sessionmaker(bind=engine) session = Session() return session engine = create_engine('postgresql+psycopg2://%s:%s@%s:5432/%s' % (config['postgresql']['user'], config['postgresql']['password'], config['postgresql']['host'], config['postgresql']['database']), ) Base = declarative_base() La variable Base d\u00e9finie ici servira \u00e0 instancier tous les mod\u00e8les de la BDD par h\u00e9ritage . Flask Flask est un framework Python qui permet de cr\u00e9er des sites web et API. Il ne s'agit pas forc\u00e9ment du framework le plus simple, surtout quand on en vient \u00e0 la gestion du contexte, mais il reste tr\u00e8s efficace et rapide. De plus il est l\u00e9ger et accompagn\u00e9 de plusieurs extensions avec des modules d\u00e9j\u00e0 existants. Pour les projets en Flask, la structure la plus pratique et qui nous int\u00e9resse le plus en terme de qualit\u00e9 d'architecture est celle ci: . \u251c\u2500\u2500 requirements.txt \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 server-conf/ \u2502 \u251c\u2500\u2500 nginx.conf \u2502 \u251c\u2500\u2500 uwsgi.ini \u2502 \u251c\u2500\u2500 supervisord.conf \u2502 \u2514\u2500\u2500 flask-site-nginx.conf \u2514\u2500\u2500 app/ \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 conf/ \u2502 \u251c\u2500\u2500 config.ini \u2502 \u2514\u2500\u2500 log-config.ini \u251c\u2500\u2500 donnees/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 routes.py \u251c\u2500\u2500 media/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 routes.py \u251c\u2500\u2500 polluant/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 routes.py \u251c\u2500\u2500 exploitation/ \u2502 \u2514\u2500\u2500 debug.log \u251c\u2500\u2500 models/ \u2502 \u251c\u2500\u2500 Donnees.py \u2502 \u251c\u2500\u2500 Medias.py \u2502 \u251c\u2500\u2500 Polluant.py \u2502 \u2514\u2500\u2500 Engine.py \u2514\u2500\u2500 utils/ \u2514\u2500\u2500 authUtils.py Le __init .py dans app/ va servir \u00e0 instancier tous les blueprints et les enregistrer dans l'application, mais aussi \u00e0 cr\u00e9er l'application en elle-m\u00eame, d\u00e9finir son port d'acc\u00e8s, etc. Les blueprints enregistr\u00e9s dans le init \u00e0 la racine proviendront des sous-dossiers. Chaque sous-dossier non commun correspond \u00e0 un endpoint. Chaque endpoint aura son blueprint qui est d\u00e9fini dans le __init .py de chaque sous-dossier. Ensuite les routes li\u00e9es \u00e0 ce blueprint sont cr\u00e9\u00e9es dans le fichier routes.py puis import\u00e9es dans le __init__.py du sous-dossier. Une chaine classique serait donc: # Finier __init__.py dans app/ from flask import Flask, jsonify, Blueprint from flask_cors import CORS from .donnees import dataBP from .conf.config import Config import logging, logging.config def create_app(config_class=Config): app = Flask(__name__) app.config.from_object(config_class) app.register_blueprint(dataBP) #routes : /donnees, /donnees/<id> logging.config.fileConfig(\"/project/src/backoffice/app/conf/log-config.ini\") cors = CORS(app, supports_credentials=True) bp = Blueprint('api', __name__, url_prefix=\"/api\") return app app = create_app() if __name__ == '__main__': create_app().run(port=5001) # Fichier __init__.py dans app/donnees/ from flask import Blueprint dataBP = Blueprint('donnees', __name__, url_prefix=\"/api/donnees\") from . import route # Fichier routes.py dans app/donnees/ from flask import jsonify, request, current_app from ..utils.authUtils import token_required from . import dataBP # Import du blueprint pour d\u00e9clarer nos routes @dataBP.route('/', methods=['GET']) #Route de base /api/donnees -> toutes les donn\u00e9es pour le tableau @token_required def getDonnees(user): return @dataBP.route('/<int:id>', methods=['GET']) #Donn\u00e9e sp\u00e9cifique @token_required def getDonnee(user, id): return @dataBP.route('/', methods=['POST']) @token_required def setDonnee(user): #MAJ ou cr\u00e9ation d'une donn\u00e9e return","title":"Conventions"},{"location":"conventions/#documentation-python","text":"Cette page r\u00e9pertorie toutes les conventions que nous appliquerons aux d\u00e9veloppements impliquant du Python, elles permettront d'uniformiser notre code afin de faciliter la reprise, la maintenance et la compr\u00e9hension par nos successeurs. La documentation qualit\u00e9 s'appuiera sur la PEP 8 afin de la rendre la plus g\u00e9n\u00e9rique et \u00e9volutive possible.Tout en ajoutant et en modifiant certains \u00e9l\u00e9ments. ( PEP 8 )","title":"Documentation Python"},{"location":"conventions/#la-pep-8","text":"","title":"La PEP 8"},{"location":"conventions/#introduction","text":"La PEP 8 est un document \u00e9crit par les cr\u00e9ateurs de Python, il contient les conventions de codage Python les plus r\u00e9pendues de nos jours, elle est r\u00e9guli\u00e8rement mise \u00e0 jour et disponible pour tous. Il en existe \u00e9galement une d\u00e9clinaison pour la langage C, mais nous ne la d\u00e9taillerons pas ici. L'objectif principal des normes est de rendre le code plus lisible et plus simple \u00e0 reprendre, on n'a pas forc\u00e9ment envie de reprendre 3000 lignes empact\u00e9es sans instructions, pas vrai ? ;) Voici donc quelques cr\u00e9dos qui pourront vous guider dans votre reflexion : PEP 20","title":"Introduction"},{"location":"conventions/#application","text":"Le plus important lors de l'\u00e9criture d'un code est l'assiduit\u00e9, et encore plus lors de l'\u00e9criture d'une fonction ou d'un petit bout de code, c'est \u00e0 ce moment qu'il faudra la rendre la plus g\u00e9n\u00e9rique possible pour qu'elle soit potentiellement r\u00e9utilisable dans des projets futurs ou m\u00eame dans le m\u00eame projet, c'est toujours plaisant de pouvoir r\u00e9utiliser quelque chose qui marche bien sans avoir \u00e0 tout r\u00e9\u00e9crire ! Cependant dans certains cas ces recommendations ne sont pas forc\u00e9ment \u00e0 appliquer surtout si le projet ne s'y pr\u00eate pas, ou bien dans le cas de l'utilisation d'un framework particulier qui n\u00e9cessiterait une syntaxe particuli\u00e8re (exemple: d\u00e9corateurs des routes Flask) Quelques exemples de cas o\u00f9 l'application des principes pourrait \u00eatre \u00e0 \u00e9viter: Suivre le guide rendrait le code moins lisible Le code autours suit une autre convention La version de Python utilis\u00e9e dans le reste du code n'est pas compatible avec la nouvelle syntaxe","title":"Application"},{"location":"conventions/#structuration-du-code","text":"","title":"Structuration du code"},{"location":"conventions/#indentation","text":"L'indentation des lignes se fait \u00e0 l'aide des espaces, 1 indentation = 4 espaces Si vous utilisez VSCode pour travailler, vous pouvez d\u00e9finir ce param\u00e8tre dans la barre d'outils tout en bas : Spaces > Change tab display size > 4.","title":"Indentation"},{"location":"conventions/#les-fonctions","text":"Lors de l'\u00e9criture d'une fonction ou d'un appel fonction, les arguments peuvent prendre \u00e9norm\u00e9ment de place sur la ligne, nous verrons plus tard la limite \u00e0 respecter, en attendant, lorsque l'appel ou la liste d'arguments est trop longue, les arguments doivent \u00eatre plac\u00e9s \u00e0 la ligne: # On peut aligner les arguments sur la paranth\u00e8se d'ouverture def nom_de_fonction_long(param_1, param_2, param_3, param_4): print(param_1) resultat = nom_de_fonction_long(param_1, param_2, param_3, param_4) # Ou alors # On placera les arguments en dessous avec une indentation suppl\u00e9mentaire par rapport au code de la fonction # Afin de diff\u00e9rencier les arguments du code def nom_de_fonction_long( param_1, param_2, param_3, param_4): print(param_1) resultat = nom_de_fonction_long( param_1, param_2, param_3, param_4) # Ou: resultat = nom_de_fonction_long( param_1, param_2, param_3, param_4 )","title":"Les fonctions"},{"location":"conventions/#les-conditions","text":"Lors de la constitution d'une condition, il se peut qu'il y ait plusieurs \"and\" ou \"or\", cela peut rendre la ligne particuli\u00e8rement longue, ainsi nous ferons le d\u00e9coupage de la mani\u00e8re suivante: # Chaque 'and' ou 'or' sera sur une nouvelle ligne 4 espaces plus loin que la parenth\u00e8se d'ouverture, soit 1 indentation. if (condition1 and condition2 and condition3 or condition4): return","title":"Les conditions"},{"location":"conventions/#les-listes-et-dictionnaires","text":"Afin de conserver une forme qui reste lisible lors de la d\u00e9finition d'une liste ou d'un dictionnaire, s'il s'agit d'un objet \u00e0 plusieurs dimensions, on gardera toujours une forme coh\u00e9rente avec la forme r\u00e9elle qu'aura l'objet. # Dans le cas d'une liste \u00e0 1 dimension: ma_liste = [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ] # 2 dimensions: ma_liste = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10] ] # 3 dimensions: ma_liste = [ [ [1, 2, 3], [4, 5, 6] ], [ [7, 8, 9], [10, 11, 12] ] ] # Et ainsi de suite.. # Pour les dictionnaires : mon_dico = { '1': 'oui', '2': 'stiti' }","title":"Les listes et dictionnaires"},{"location":"conventions/#longueur-des-lignes-a-respecter","text":"Quand on lit un code, c'est pas marrant de scroller \u00e0 l'infini \u00e0 l'horizontale ! Pour \u00e9viter \u00e7a, on va limiter la longueur des lignes de code de mani\u00e8re \u00e0 tout garder visible \u00e0 l'\u00e9cran pour un maximum de r\u00e9solutions diff\u00e9rentes, il a donc \u00e9t\u00e9 d\u00e9cid\u00e9 que la longueur parfaite \u00e9tait de 100 caract\u00e8res maximum par ligne de code Pour ce qui est des commentaires ou des docstrings , on se limitera \u00e0 72 caract\u00e8res La seconde raison de cette limite est la possibilit\u00e9 d'avoir plusieurs \u00e9diteurs de code ouverts simultan\u00e9ment sur un m\u00eame \u00e9cran, en les mettant c\u00f4te \u00e0 c\u00f4te, avoir des lignes pas trop longues permet d'avoir une vue d'ensemble de tous les codes que nous souhaitons voir, ainsi pour les review ou m\u00eame pour coder sur diff\u00e9rentes composantes en m\u00eame temps, il est plus simple de se restreindre. Pour \u00e9viter de d\u00e9passer cette limite, on peut faire comme vu pr\u00e9c\u00e9demment, lorsqu'on est dans une parenth\u00e8se on peut passer \u00e0 la ligne. En revanche dans le cas d'un \"with\" avec plusieurs ouvertures, ou d'un \"assert\", l'utilisation du \\ peut \u00eatre utile. Voici un exemple d'utilisation: # Chaque 'and' ou 'or' sera sur une nouvelle ligne 4 espaces plus loin que la parenth\u00e8se d'ouverture, soit 1 indentation. with open('/chemin/vers/un/fichier') as fichier_1, \\\\ open('/chemin/vers/un/fichier', 'w') as fichier_2: fichier_2.write(fichier_1.read())","title":"Longueur des lignes \u00e0 respecter"},{"location":"conventions/#les-operateurs","text":"Vous avez beaucoup de calculs \u00e0 faire ? Vous n'allez tout de m\u00eame pas tout mettre sur la m\u00eame ligne apr\u00e8s tout ce qu'on vient de dire ? ;) Pour chaque bloc d'op\u00e9ration, nous s\u00e9parerons en faisant un saut \u00e0 la ligne et en mettant l'op\u00e9rateur en d\u00e9but de ligne comme ceci: # L'op\u00e9rateur sera align\u00e9 avec la parenth\u00e8se d'ouverture revenu = (salaire - budget_codage + prime_de_votre_gentil_chef * 1.1) #Pour le plaisir","title":"Les op\u00e9rateurs"},{"location":"conventions/#les-sauts-de-lignes","text":"C'est bien connu, un gros bloc, \u00e7a donne pas envie de lire. On va donc espacer notre code en sautant des lignes aux bons endroits et sans en abuser pour ne pas retirer la coh\u00e9rence du code. # 1. Un saut de ligne entre les fonctions def func_1(): return def func_2(): return # 2. Deux sauts de ligne entre les m\u00e9thodes de classe et les fonctions def methode(self): return def fonction(): return # 3. Un saut de ligne entre un code et une condition variable = 1 test = 2 if variable == 1: return # 4. Dans les fonctions, 1 saut de ligne entre chaque bloc logique def fonction(): variable = 1 autre_variable = 1 with open('test') as test: print(test) return","title":"Les sauts de lignes"},{"location":"conventions/#les-imports","text":"Les imports devront toujours se situer au d\u00e9but du code apr\u00e8s le header de documentation , jamais plus loin. Il faudra les d\u00e9coupler sur plusieurs lignes s'ils ne sont pas li\u00e9s entre eux. Ils devront \u00eatre import\u00e9s dans l'ordre suivant: Librairies standard Python Librairies tierces Modules internes au code # Correct: import os import sys # Dans le cas d'imports venant d'un m\u00eame package, il est recommand\u00e9 de les mettre sur la m\u00eame ligne: from subprocess import Popen, PIPE # Les imports absolus sont recommand\u00e9s quand la structure du projet est complexe from . import voisin from .voisin import fonction","title":"Les imports"},{"location":"conventions/#la-documentation-du-module","text":"Au d\u00e9but d'un module, avant tout code, il faut bien \u00e9crire la documentation afin de savoir tout de suite quelle est son utilit\u00e9 ou encore \u00e0 qui se r\u00e9ferrer s'il y a un probl\u00e8me ou des questions. Cette documentation fait partie du \"docstring\" qui est un peu la \"carte d'identit\u00e9\" du projet, on va documenter chaque module et chaque fonction. Tout d'abord pour les modules, la documentation se pr\u00e9sentera comme ceci: \"\"\"Module d exemple Description de la fonction principale du module, ex: Permet d exporter des donn\u00e9es au format CSV \"\"\" from __future__ import annotations __all__ = [\"variable1\", \"variable2\", \"variable3\"] __version__ = \"1.0\" __author__ = \"Alex Lovergne\" import os import sys def fonction_exemple(arg1: String, arg2: String) -> String: \"\"\"Fonction d exemple, d\u00e9finition de son utilit\u00e9 args: - arg1 : String -> Premi\u00e8re chaine de caract\u00e8re - arg2 : String -> Deuxi\u00e8me chaine de caract\u00e8re \u00e0 concat\u00e9ner returns: String -> Concatenation des deux chaines \"\"\" return arg1 + arg2 La variable __all__ permet de d\u00e9finir le nom des variables qui seront export\u00e9es du module, par exemple si on a une variable a = 0 d\u00e9finie dans le module et que l'on importe le module ailleurs, seule la variable a sera import\u00e9e.","title":"La documentation du module"},{"location":"conventions/#les-espaces","text":"Les espacements dans le code sont tr\u00e8s utiles pour am\u00e9liorer sa lisibilit\u00e9 et le rendre plus a\u00e9r\u00e9. On aime bien avoir de la place entre son canap\u00e9 et sa t\u00e9l\u00e9vision pour bien voir, dans le code c'est pareil. Il est important toute fois de ne pas mettre des espaces partout, il y a des emplacements bien d\u00e9finis pour faciliter la lecture et la d\u00e9tection rapide de certaines instructions ou syntaxes. # Entre les parenth\u00e8ses et les valeurs, pas d'espaces acheter(viande[1], {oeufs: 2}) exemple = (0,) # 1 espace apr\u00e8s les ':' et les ',' mais pas avant. # Jamais d espaces entre le nom de fonction et ses arguments. Entre une liste et ses crochets if x == 4: print(x, y); x, y = y, x def fonction_exemple(arg1: String, arg2: String) -> String: dct['key'] = lst[index] # Toujours un espace de chaque c\u00f4t\u00e9 du '=', '+', '-', '/', '->' i = i + 1 ajout += 1 x = x*2 - 1 hypot2 = x*x + y*y + y / 2 c = (a+b) * (a-b)","title":"Les espaces"},{"location":"conventions/#les-commentaires","text":"Rapide point sur les commentaires, vous devez en avoir marre, les commentaires c'est long et barbant \u00e0 faire mais malheureusement c'est ce qui va aider votre prochain (on est pas \u00e0 l'\u00e9glise rassurez vous). Ainsi \u00e9crire des commentaires pour expliquer les points importants du code sont primordiaux surtout s'il s'agit d'un traitement m\u00e9tier qu'un autre d\u00e9veloppeur pourrait ne pas ma\u00eetriser. Attention cependant \u00e0 les utiliser avec mod\u00e9ration, Un commentaire \u00e0 chaque ligne, c'est comme de la moquette sur un mur, c'est d\u00e9rangeant Vous pouvez les mettre sur une nouvelle ligne ou bien en fin de ligne \u00e0 2 espaces d'intervalle de la fin de la ligne de code. N'oubliez pas la limite de caract\u00e8res par ligne !","title":"Les commentaires"},{"location":"conventions/#les-conventions","text":"","title":"Les conventions"},{"location":"conventions/#nommage","text":"","title":"Nommage"},{"location":"conventions/#les-variables-et-fonctions","text":"Les variables doivent toujours avoir un nom explicite , il faut \u00e9viter les variables ayant un nom comme \"a\" ou \"b\", mais plut\u00f4t \"liste mots\" ou \"dico_noms\" par exemple. Ensuite, il y a des conventions sur le nommage des variables, en effet on privil\u00e9giera les **variables en lettres minuscules, s'il y a plusieurs mots on les s\u00e9parera avec un \" \", de la forme : liste_mots_a_trier** (c'est un exemple, ne faites pas des noms aussi longs). Pour ce qui est des fonctions, nous partirons sur le m\u00eame principe, il s'agit du snake_case.","title":"Les variables et fonctions"},{"location":"conventions/#les-classes-et-modules","text":"Les noms de classes et les modules ont une syntaxe diff\u00e9rente, au lieu d'utiliser des lettres en minuscule et des tirets du bas, on va utiliser le CamelCase . Il s'agit de nommer en collant les mots, \u00e0 chaque nouveau mot on met une majuscule de cette mani\u00e8re: JeSuisUnNomDeVariable (pas aussi long svp).","title":"Les classes et modules"},{"location":"conventions/#les-constantes","text":"Les constantes seront toujours d\u00e9finies au d\u00e9but du script apr\u00e8s la documentation et les imports. Ou alors dans les fichiers de config, ils seront d\u00e9finis en majuscules, les mots seront s\u00e9par\u00e9s par des \"_\" De la mani\u00e8re suivante: JE_SUIS_UNE_CONSTANTE Petit rappel: Une constante est une variable qui sera d\u00e9finie lors de l'\u00e9criture du code et ne sera JAMAIS modifi\u00e9e apr\u00e8s.","title":"Les constantes"},{"location":"conventions/#configuration-deportee","text":"Quand on a de l'argent liquide, on se prom\u00e8ne jamais avec tout sur nous ? Dans le code c'est pareil , on ne veut pas que nos mots de passes soient visibles pour tous les gens qui auraient acc\u00e8s \u00e0 notre repo git. On n'a pas non plus envie d'aller modifier partout si un mot de passe ou une valeur change ? C'est pour \u00e7a qu'on va d\u00e9porter notre configuration, de cette mani\u00e8re on \u00e9vite tous les probl\u00e8mes occasionn\u00e9s par les chaines \u00e9crites en dur dans le code, mais aussi on renforce la s\u00e9curit\u00e9 de notre programme \u00e9tant donn\u00e9 qu'on ne publiera pas le fichier de config rempli mais plut\u00f4t une version d'exemple pour aiguiller une personne qui voudrait reprendre notre code mais qui n'aurait pas les m\u00eames acc\u00e8s que nous. Mais comment on fait ? C'est tr\u00e8s simple, dans le dossier racine de notre projet, on va cr\u00e9er un nouveau dossier settings . Dans ce dossier nous allons cr\u00e9er un fichier config.ini et config_exemple.ini . Dans le fichier config.ini nous allons placer nos variables qui seront accessibles depuis notre code comme ceci : [exemple_1] host=srv-exemple1 database=microcapteurs user=exemple password=exemple [exemple_2] host=srv-exemple2 database=microcapteurs user=exemple2 password=exemple2 Ensuite, dans notre fichier config_exemple.ini nous allons placer exactement les m\u00eames variables mais en renseignant de fausses informations . Comment r\u00e9cup\u00e9rer nos variables de configuration ? C'est tr\u00e8s simple, dans notre programme Python nous allons utiliser le module \"configparser\" , il s'utilise comme ceci: import configparser config = configparser.ConfigParser() # Initialisation du module config.read('./settings/config.ini') # Import de notre configuration print(config['exemple_1']['host']) # On peut r\u00e9cup\u00e9rer notre configuration \u00e0 la mani\u00e8re d'un dictionnaire print(config['exemple_2']['user'])","title":"Configuration d\u00e9port\u00e9e"},{"location":"conventions/#logging","text":"Il est toujours important de garder une trace de l'ex\u00e9cution de notre programme afin de faciliter son debuggage en cas de probl\u00e8me. Pour cela nous n'utiliserons \u00e9videmment pas la fonction print mais bien la librairie logging Cette librairie Python permet de param\u00e9trer une ou plusieurs sorties pour ce qu'on voudrait afficher/stocker. Il est ainsi possible par exemple pour un logging.info() d'enregistrer le r\u00e9sultat dans un fichier .log mais en m\u00eame temps de l'afficher dans la console. Comment l'utiliser ? Commen\u00e7ons tout d'abord par cr\u00e9er un fichier log-config.ini qui sera situ\u00e9 dans un dossier settings \u00e0 la racine du programme. Dans ce fichier nous pla\u00e7erons ce contenu: [loggers] keys=root [handlers] keys=consoleHandler,fileHandler [formatters] keys=default [logger_root] level=NOTSET handlers=consoleHandler,fileHandler [handler_consoleHandler] class=StreamHandler level=NOTSET formatter=default args=(sys.stdout,) [handler_fileHandler] class=handlers.RotatingFileHandler level=NOTSET args=('debug.log',2000,100) formatter=default encoding=utf-8 [formatter_default] format=%(asctime)s %(levelname)s %(message)s datefmt= style=% validate=True class=logging.Formatter Il s'agira de notre configuration standard qui sera utilis\u00e9e pour tous nos projets, elle permet de log dans la console mais aussi dans un fichier debug.log \u00e0 la racine. Le format de sortie sera du type: YY-MM-DD H:M:S,MS INFO message affich\u00e9 Maintenant que notre fichier de config est cr\u00e9\u00e9, nous pouvons l'importer dans notre programme principal, et en suite utiliser la bibioth\u00e8que logging. import logging import logging.config logging.config.fileConfig('settings/log-config.ini') # Chargement de la config -> 1 seule fois dans le main logging.info('information') # Pour afficher une \u00e9tape par exemple logging.warning('attention') # Exemple: condition non respect\u00e9e mais non bloquante logging.error('erreur') # Erreur, fin du programme","title":"Logging"},{"location":"conventions/#dependances","text":"Qui n'a jamais r\u00eav\u00e9 de tout installer en une seule commande ? C'est bien pour \u00e7a que les requirements existent et sont utilis\u00e9s. Ils vont permettre d'installer toutes les d\u00e9pendances de notre projet avec une unique commande, ce qui permet d'\u00e9viter les oublis, de fixer une version bien d\u00e9finie avec laquelle le programme est compatible mais aussi de gagner du temps et \u00e9viter les potentielles failles de s\u00e9curit\u00e9. Mais comment qu'on fait ? C'est tr\u00e8s simple, il suffit de cr\u00e9er un fichier requirements.txt \u00e0 la racine du projet. Dans ce fichier nous allons lister nos d\u00e9pendances ainsi que les versions de cette mani\u00e8re: numpy==1.24.2 requests==2.28.2 urllib3==1.26.14 # Module == version Ensuite une fois que c'est fait, on a d\u00e9j\u00e0 fini. Pour installer les d\u00e9pendances il faut taper la commande: pip install -r requirements.txt","title":"D\u00e9pendances"},{"location":"conventions/#modularisation","text":"On ne veut pas avoir tout notre code dans un seul fichier, c'est moche de scroll \u00e0 l'infini pas vrai ? On va donc chercher \u00e0 d\u00e9coupler un maximum notre code en plusieurs modules, dans l'id\u00e9al 1 module par utilit\u00e9. Exemple: J'ai un fichier main.py avec 6 fonctions, une pour exporter des donn\u00e9es dans une BDD, une autre pour importer les donn\u00e9es d'une source (microcapteur par exemple), et 4 autres pour faire des conversions. Comment organiser mon code ? Une proposition pourrait \u00eatre de l'organiser de la mani\u00e8re suivante: On va s'assurer que chaque module de donn\u00e9es soit g\u00e9n\u00e9rique, pour se faire nous utiliserons des interfaces (Sensor.py) . \u251c\u2500\u2500 main.py \u251c\u2500\u2500 requirements.txt \u251c\u2500\u2500 debug.log \u251c\u2500\u2500 settings/ \u2502 \u251c\u2500\u2500 config.ini \u2502 \u251c\u2500\u2500 config_example.ini \u2502 \u2514\u2500\u2500 log-config.ini \u251c\u2500\u2500 utils/ \u2502 \u2514\u2500\u2500 converters.py \u251c\u2500\u2500 database/ \u2502 \u2514\u2500\u2500 Database.py \u2514\u2500\u2500 sensors/ \u251c\u2500\u2500 Kunak.py \u2514\u2500\u2500 Sensor.py","title":"Modularisation"},{"location":"conventions/#les-interfaces","text":"Qu'est-ce qu'une interface ? Une interface est une classe Python qui permet de d\u00e9finir un cadre qui sera appliqu\u00e9 aux classes h\u00e9ritantes. Mais \u00e7a veut dire quoi ? Voici un exemple simple: J'ai une interface Sensor J'ai une classe Kunak La classe Sensor se d\u00e9finit de la mani\u00e8re suivante: class Sensor: def __init__(self, name: str, constructor: str) -> None: self._name = name self._constructor = constructor @property def name(self) -> str: return self._name @name.setter def name(self, new_name: str): self._name = new_name @property def constructor(self) -> str: return self._constructor @constructor.setter def constructor(self, new_constructor: str): self._constructor = new_constructor def __repr__(self) -> str: return \"<sensor %s - constructor:%s>\" % ( self._name, self._constructor) La classe Kunak, quant a elle est d\u00e9finie comme ceci: class Kunak(Sensor): # H\u00e9rite de l'interface Sensor def __init__(self, *args) -> None: super().__init__(*args) # Charge la classe parent Ainsi, si on cr\u00e9\u00e9 un objet de la classe Kunak on aura: kun = Kunak('K100', 'Kunak') print(kun) >>> <sensor K100 - Kunak> La classe de l'objet sera donc 'Kunak', h\u00e9ritant de Sensor. Elle b\u00e9n\u00e9ficie donc de toutes les m\u00e9thodes et attributs d\u00e9finits dans la classe parent.","title":"Les interfaces"},{"location":"conventions/#boite-a-outils","text":"","title":"Bo\u00eete \u00e0 outils"},{"location":"conventions/#sql-alchemy","text":"SQL Alchemy est un module Python qui sert \u00e0 int\u00e9ragir avec la base de donn\u00e9es , on appelle \u00e7a un ORM ou Object-Relational Mapping . Il s'agit d'un type de programme informatique qui se place en interface entre un programme applicatif et une base de donn\u00e9es relationnelle pour simuler une base de donn\u00e9es orient\u00e9e objet. ( Voir wikip\u00e9dia ) Pour utiliser SQL Alchemy et le relier \u00e0 notre base de donn\u00e9es, il est n\u00e9cessaire de cr\u00e9er nos mod\u00e8les . Qu'est-ce qu'un mod\u00e8le ? Un mod\u00e8le dans notre cas est une classe Python portant le nom d'une table de notre base de donn\u00e9es, et qui r\u00e9pertorie les colonnes dont on va avoir besoin. Elles doivent exister dans la BDD. Dans le cas o\u00f9 la BDD n'existerait pas encore, les tables seront cr\u00e9\u00e9es en fonction des mod\u00e8les d\u00e9finis dans le code. Voici un exemple de mod\u00e8le: import sqlalchemy as sa from dbModels.Engine import Base class Capteurs(Base): __tablename__ = 'capteurs' id = sa.Column(sa.Integer, nullable=False, primary_key=True) constructeur = sa.Column(sa.VARCHAR) reference_constructeur = sa.Column(sa.VARCHAR) position_actuelle = sa.Column(sa.VARCHAR) modele = sa.Column(sa.VARCHAR) notes = sa.Column(sa.Text) campagne_mesure_actuelle_id = sa.Column(sa.Integer) date_mise_en_service = sa.Column(sa.Date) date_arret = sa.Column(sa.Date) etat = sa.Column(sa.VARCHAR) def __init__(self, id, constructeur, reference_constructeur, position_actuelle, modele, notes, campagne_mesure_actuelle_id, date_mise_en_service, date_arret, etat): self.id = id self.constructeur = constructeur self.reference_constructeur = reference_constructeur self.position_actuelle = position_actuelle self.modele = modele self.notes = notes self.campagne_mesure_actuelle_id = campagne_mesure_actuelle_id self.date_mise_en_service = date_mise_en_service self.date_arret = date_arret self.etat = etat def __repr__(self): return \"<capteur n\u00b0%s - %s - reference -> %s>\" % ( self.id, self.constructeur, self.reference_constructeur) Et l'engine qui repr\u00e9sente la base de notre connexion \u00e0 la BDD est difini de la mani\u00e8re suivante: from sqlalchemy import create_engine from sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import sessionmaker import configparser config = configparser.ConfigParser() config.read(\"./settings/config.ini\") def loadSession(): metadata = Base.metadata Session = sessionmaker(bind=engine) session = Session() return session engine = create_engine('postgresql+psycopg2://%s:%s@%s:5432/%s' % (config['postgresql']['user'], config['postgresql']['password'], config['postgresql']['host'], config['postgresql']['database']), ) Base = declarative_base() La variable Base d\u00e9finie ici servira \u00e0 instancier tous les mod\u00e8les de la BDD par h\u00e9ritage .","title":"SQL Alchemy"},{"location":"conventions/#flask","text":"Flask est un framework Python qui permet de cr\u00e9er des sites web et API. Il ne s'agit pas forc\u00e9ment du framework le plus simple, surtout quand on en vient \u00e0 la gestion du contexte, mais il reste tr\u00e8s efficace et rapide. De plus il est l\u00e9ger et accompagn\u00e9 de plusieurs extensions avec des modules d\u00e9j\u00e0 existants. Pour les projets en Flask, la structure la plus pratique et qui nous int\u00e9resse le plus en terme de qualit\u00e9 d'architecture est celle ci: . \u251c\u2500\u2500 requirements.txt \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 server-conf/ \u2502 \u251c\u2500\u2500 nginx.conf \u2502 \u251c\u2500\u2500 uwsgi.ini \u2502 \u251c\u2500\u2500 supervisord.conf \u2502 \u2514\u2500\u2500 flask-site-nginx.conf \u2514\u2500\u2500 app/ \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 conf/ \u2502 \u251c\u2500\u2500 config.ini \u2502 \u2514\u2500\u2500 log-config.ini \u251c\u2500\u2500 donnees/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 routes.py \u251c\u2500\u2500 media/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 routes.py \u251c\u2500\u2500 polluant/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 routes.py \u251c\u2500\u2500 exploitation/ \u2502 \u2514\u2500\u2500 debug.log \u251c\u2500\u2500 models/ \u2502 \u251c\u2500\u2500 Donnees.py \u2502 \u251c\u2500\u2500 Medias.py \u2502 \u251c\u2500\u2500 Polluant.py \u2502 \u2514\u2500\u2500 Engine.py \u2514\u2500\u2500 utils/ \u2514\u2500\u2500 authUtils.py Le __init .py dans app/ va servir \u00e0 instancier tous les blueprints et les enregistrer dans l'application, mais aussi \u00e0 cr\u00e9er l'application en elle-m\u00eame, d\u00e9finir son port d'acc\u00e8s, etc. Les blueprints enregistr\u00e9s dans le init \u00e0 la racine proviendront des sous-dossiers. Chaque sous-dossier non commun correspond \u00e0 un endpoint. Chaque endpoint aura son blueprint qui est d\u00e9fini dans le __init .py de chaque sous-dossier. Ensuite les routes li\u00e9es \u00e0 ce blueprint sont cr\u00e9\u00e9es dans le fichier routes.py puis import\u00e9es dans le __init__.py du sous-dossier. Une chaine classique serait donc: # Finier __init__.py dans app/ from flask import Flask, jsonify, Blueprint from flask_cors import CORS from .donnees import dataBP from .conf.config import Config import logging, logging.config def create_app(config_class=Config): app = Flask(__name__) app.config.from_object(config_class) app.register_blueprint(dataBP) #routes : /donnees, /donnees/<id> logging.config.fileConfig(\"/project/src/backoffice/app/conf/log-config.ini\") cors = CORS(app, supports_credentials=True) bp = Blueprint('api', __name__, url_prefix=\"/api\") return app app = create_app() if __name__ == '__main__': create_app().run(port=5001) # Fichier __init__.py dans app/donnees/ from flask import Blueprint dataBP = Blueprint('donnees', __name__, url_prefix=\"/api/donnees\") from . import route # Fichier routes.py dans app/donnees/ from flask import jsonify, request, current_app from ..utils.authUtils import token_required from . import dataBP # Import du blueprint pour d\u00e9clarer nos routes @dataBP.route('/', methods=['GET']) #Route de base /api/donnees -> toutes les donn\u00e9es pour le tableau @token_required def getDonnees(user): return @dataBP.route('/<int:id>', methods=['GET']) #Donn\u00e9e sp\u00e9cifique @token_required def getDonnee(user, id): return @dataBP.route('/', methods=['POST']) @token_required def setDonnee(user): #MAJ ou cr\u00e9ation d'une donn\u00e9e return","title":"Flask"},{"location":"installation/","text":"Installation de Python Table des mati\u00e8res Installation sur Windows Installation sur Linux Installation sur macOS Installation sur Windows \u00c9tape 1 : T\u00e9l\u00e9charger Python Rendez-vous sur le site officiel de Python . T\u00e9l\u00e9chargez l'installateur pour Windows (la derni\u00e8re version stable). \u00c9tape 2 : Installation de Python Ex\u00e9cutez l'installateur que vous venez de t\u00e9l\u00e9charger. Important : Cochez la case \"Add Python to PATH\" avant de cliquer sur \"Install Now\". Cliquez sur Install Now et suivez les instructions. \u00c9tape 3 : V\u00e9rifier l'installation Ouvrez l'invite de commande (Windows + R, tapez cmd ). Tapez python --version pour v\u00e9rifier la version install\u00e9e. Installation sur Linux \u00c9tape 1 : Mettre \u00e0 jour les packages Avant d'installer Python, assurez-vous que les paquets sont \u00e0 jour : sudo apt update && sudo apt upgrade \u00c9tape 2 : Installer Python Pour Ubuntu ou Debian, utilisez la commande suivante : sudo apt install python3 Pour Fedora : sudo dnf install python3 Pour Arch Linux : sudo pacman -S python \u00c9tape 3 : V\u00e9rifier l'installation Tapez python3 --version pour v\u00e9rifier la version install\u00e9e. Installation sur macOS \u00c9tape 1 : T\u00e9l\u00e9charger Python Rendez-vous sur le site officiel de Python . T\u00e9l\u00e9chargez l'installateur pour macOS (la derni\u00e8re version stable). \u00c9tape 2 : Installation de Python Ouvrez le fichier .pkg t\u00e9l\u00e9charg\u00e9. Suivez les instructions de l'installateur.","title":"Installation"},{"location":"installation/#installation-de-python","text":"","title":"Installation de Python"},{"location":"installation/#table-des-matieres","text":"Installation sur Windows Installation sur Linux Installation sur macOS","title":"Table des mati\u00e8res"},{"location":"installation/#installation-sur-windows","text":"","title":"Installation sur Windows"},{"location":"installation/#etape-1-telecharger-python","text":"Rendez-vous sur le site officiel de Python . T\u00e9l\u00e9chargez l'installateur pour Windows (la derni\u00e8re version stable).","title":"\u00c9tape 1 : T\u00e9l\u00e9charger Python"},{"location":"installation/#etape-2-installation-de-python","text":"Ex\u00e9cutez l'installateur que vous venez de t\u00e9l\u00e9charger. Important : Cochez la case \"Add Python to PATH\" avant de cliquer sur \"Install Now\". Cliquez sur Install Now et suivez les instructions.","title":"\u00c9tape 2 : Installation de Python"},{"location":"installation/#etape-3-verifier-linstallation","text":"Ouvrez l'invite de commande (Windows + R, tapez cmd ). Tapez python --version pour v\u00e9rifier la version install\u00e9e.","title":"\u00c9tape 3 : V\u00e9rifier l'installation"},{"location":"installation/#installation-sur-linux","text":"","title":"Installation sur Linux"},{"location":"installation/#etape-1-mettre-a-jour-les-packages","text":"Avant d'installer Python, assurez-vous que les paquets sont \u00e0 jour : sudo apt update && sudo apt upgrade","title":"\u00c9tape 1 : Mettre \u00e0 jour les packages"},{"location":"installation/#etape-2-installer-python","text":"Pour Ubuntu ou Debian, utilisez la commande suivante : sudo apt install python3 Pour Fedora : sudo dnf install python3 Pour Arch Linux : sudo pacman -S python","title":"\u00c9tape 2 : Installer Python"},{"location":"installation/#etape-3-verifier-linstallation_1","text":"Tapez python3 --version pour v\u00e9rifier la version install\u00e9e.","title":"\u00c9tape 3 : V\u00e9rifier l'installation"},{"location":"installation/#installation-sur-macos","text":"","title":"Installation sur macOS"},{"location":"installation/#etape-1-telecharger-python_1","text":"Rendez-vous sur le site officiel de Python . T\u00e9l\u00e9chargez l'installateur pour macOS (la derni\u00e8re version stable).","title":"\u00c9tape 1 : T\u00e9l\u00e9charger Python"},{"location":"installation/#etape-2-installation-de-python_1","text":"Ouvrez le fichier .pkg t\u00e9l\u00e9charg\u00e9. Suivez les instructions de l'installateur.","title":"\u00c9tape 2 : Installation de Python"}]}